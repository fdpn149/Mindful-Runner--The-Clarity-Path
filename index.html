<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mindful Runner: è¦ºçŸ¥ä¹‹è·¯</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
      @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700&display=swap');
      body {
        font-family: 'Noto Sans TC', sans-serif;
        background-color: #0f172a;
        color: #e2e8f0;
        overflow: hidden;
        touch-action: none; /* ç¦æ­¢æ‰‹æ©Ÿç€è¦½å™¨çš„é è¨­æ‰‹å‹¢(å¦‚ç¸®æ”¾ã€æ»‘å‹•ç¿»é ) */
        user-select: none; /* ç¦æ­¢é¸å–æ–‡å­— */
        -webkit-user-select: none;
      }
      @keyframes shake {
        0% { transform: translate(1px, 1px) rotate(0deg); }
        10% { transform: translate(-1px, -2px) rotate(-1deg); }
        20% { transform: translate(-3px, 0px) rotate(1deg); }
        30% { transform: translate(3px, 2px) rotate(0deg); }
        40% { transform: translate(1px, -1px) rotate(1deg); }
        50% { transform: translate(-1px, 2px) rotate(-1deg); }
        60% { transform: translate(-3px, 1px) rotate(0deg); }
        70% { transform: translate(3px, 1px) rotate(-1deg); }
        80% { transform: translate(-1px, -1px) rotate(1deg); }
        90% { transform: translate(1px, 2px) rotate(0deg); }
        100% { transform: translate(1px, -2px) rotate(-1deg); }
      }
      .animate-shake {
        animation: shake 0.5s;
        animation-iteration-count: infinite;
      }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-presets="react,typescript">
        const { useState, useEffect, useRef } = React;

        // --- Constants ---
        const LANES = 3;
        const PLAYER_Y_POS = 80;
        
        // éŠæˆ²é€Ÿåº¦è¨­å®š (0.5 ç‚ºæ¨™æº–é€Ÿåº¦)
        const GAME_SPEED_INITIAL = 0.5; 
        
        const SPAWN_RATE_INITIAL = 60;
        const MAX_SANITY = 100;
        const SANITY_DECAY = 0.05;
        const SANITY_RESTORE = 20;

        // Enum æ¨¡æ“¬
        const GameState = {
            START: 'START',
            PLAYING: 'PLAYING',
            GAME_OVER: 'GAME_OVER',
        };

        const ObstacleType = {
            KETAMINE: 'KETAMINE',
            WEED: 'WEED',
            METH: 'METH',
            FRIEND: 'FRIEND',
        };

        const PowerUpType = {
            ZEN: 'ZEN',
            KNOWLEDGE: 'KNOWLEDGE'
        };

        const ENTITY_CONFIG = {
            [ObstacleType.KETAMINE]: { label: 'Kä»–å‘½', emoji: 'ğŸ¼', color: '#fb7185', damage: 15, effect: 'DIAPER', description: 'è†€èƒ±çº–ç¶­åŒ–' },
            [ObstacleType.WEED]: { label: 'å¤§éº»', emoji: 'ğŸŒ¿', color: '#4ade80', damage: 10, effect: 'FOG', description: 'è¨˜æ†¶åŠ›é€€åŒ–' },
            [ObstacleType.METH]: { label: 'å®‰éä»–å‘½', emoji: 'ğŸ’Š', color: '#60a5fa', damage: 25, effect: 'SHAKE', description: 'æš´åŠ›å‚¾å‘' },
            [ObstacleType.FRIEND]: { label: 'æå‹', emoji: 'ğŸ˜ˆ', color: '#a855f7', damage: 20, effect: null, description: 'èª˜æƒ‘èˆ‡èª¤å°' },
            [PowerUpType.ZEN]: { label: 'ç¦ªä¿®', emoji: 'ğŸ§˜', color: '#fbbf24', value: 0, effect: 'HEAL', description: 'æ¢å¾©ç†æ™º' },
            [PowerUpType.KNOWLEDGE]: { label: 'è…¦ç§‘å­¸', emoji: 'ğŸ§ ', color: '#22d3ee', value: 500, effect: 'SCORE', description: 'æ­£ç¢ºçŸ¥è­˜' },
        };

        const MASTER_QUOTES = [
            "ä¸€å¿µè¿·æ˜¯çœ¾ç”Ÿï¼Œä¸€å¿µè¦ºæ˜¯ä½›ã€‚æ–½ä¸»è«‹å†è©¦ä¸€æ¬¡ã€‚",
            "æ¯’å“å¸¶ä¾†çš„å¿«æ¨‚æ˜¯å€Ÿè²¸ï¼Œåˆ©æ¯æ˜¯ä½ çš„å¤§è…¦ã€‚",
            "è¦ºçŸ¥ç•¶ä¸‹ï¼Œå‹¿è¢«å¤–å¢ƒæ‰€è½‰ã€‚å†ä¾†éã€‚",
            "é€™ä¸€æ¬¡çš„å¤±æ•—ï¼Œæ˜¯ä¸‹ä¸€æ¬¡è¦ºé†’çš„é¤Šåˆ†ã€‚",
            "ä¿æŒæ¸…é†’ï¼Œé€™æ‰æ˜¯çœŸæ­£çš„è‡ªç”±ã€‚"
        ];

        // --- GameCanvas Component ---

        const GameCanvas = ({ gameState, setGameState, onGameOver, onScoreUpdate, onSanityUpdate }) => {
            const canvasRef = useRef(null);
            const requestRef = useRef(0);
            
            // FPS æ§åˆ¶è®Šæ•¸ (é–å®š 60 FPS)
            const lastTimeRef = useRef(0);
            const FPS = 60;
            const INTERVAL = 1000 / FPS;
            
            const scoreRef = useRef(0);
            const speedRef = useRef(GAME_SPEED_INITIAL);
            const frameCountRef = useRef(0);
            const entitiesRef = useRef([]);
            const obstaclesHitRef = useRef([]);
            const startTimeRef = useRef(0);
            
            const playerRef = useRef({
                lane: 1,
                isJumping: false,
                sanity: MAX_SANITY,
                effects: [],
                score: 0
            });

            const getLaneX = (laneIdx, canvasWidth) => {
                const laneWidth = canvasWidth / LANES;
                return laneWidth * laneIdx + laneWidth / 2;
            };

            const spawnEntity = () => {
                const rand = Math.random();
                const lane = Math.floor(Math.random() * LANES);
                let type;

                if (rand < 0.15) type = PowerUpType.ZEN;
                else if (rand < 0.20) type = PowerUpType.KNOWLEDGE;
                else if (rand < 0.40) type = ObstacleType.FRIEND;
                else if (rand < 0.60) type = ObstacleType.KETAMINE;
                else if (rand < 0.80) type = ObstacleType.WEED;
                else type = ObstacleType.METH;

                const newEntity = {
                    id: Math.random().toString(36).substr(2, 9),
                    x: lane,
                    y: -10,
                    type,
                    active: true
                };
                entitiesRef.current.push(newEntity);
            };

            const updateGame = (canvas) => {
                if (gameState !== GameState.PLAYING) return;

                frameCountRef.current++;
                
                // é›£åº¦å¢åŠ 
                if (frameCountRef.current % 600 === 0) speedRef.current += 0.05;

                const currentSpawnRate = Math.max(20, SPAWN_RATE_INITIAL - Math.floor(scoreRef.current / 500));
                if (frameCountRef.current % currentSpawnRate === 0) spawnEntity();

                entitiesRef.current.forEach(e => { e.y += speedRef.current; });
                entitiesRef.current = entitiesRef.current.filter(e => e.y < 120 && e.active);

                if (frameCountRef.current % 10 === 0) {
                    playerRef.current.sanity = Math.max(0, playerRef.current.sanity - SANITY_DECAY);
                    onSanityUpdate(playerRef.current.sanity);
                }

                const playerHitboxY = PLAYER_Y_POS;
                const hitTolerance = 5;

                entitiesRef.current.forEach(e => {
                    if (e.active && e.x === playerRef.current.lane) {
                        if (Math.abs(e.y - playerHitboxY) < hitTolerance) {
                            handleCollision(e);
                        }
                    }
                });

                playerRef.current.effects = playerRef.current.effects
                    .map(eff => ({ ...eff, duration: eff.duration - 1 }))
                    .filter(eff => eff.duration > 0);

                scoreRef.current += 1;
                onScoreUpdate(scoreRef.current);

                if (playerRef.current.sanity <= 0) endGame();
            };

            const handleCollision = (entity) => {
                entity.active = false;
                const config = ENTITY_CONFIG[entity.type];

                if (entity.type === PowerUpType.ZEN) {
                    playerRef.current.sanity = Math.min(MAX_SANITY, playerRef.current.sanity + SANITY_RESTORE);
                    playerRef.current.effects = []; 
                } else if (entity.type === PowerUpType.KNOWLEDGE) {
                    scoreRef.current += config.value || 0;
                } else {
                    playerRef.current.sanity = Math.max(0, playerRef.current.sanity - (config.damage || 10));
                    obstaclesHitRef.current.push(entity.type);
                    if (config.effect) {
                        playerRef.current.effects.push({ type: config.effect, duration: 120 });
                    }
                }
                onSanityUpdate(playerRef.current.sanity);
            };

            const endGame = () => {
                setGameState(GameState.GAME_OVER);
                const duration = (Date.now() - startTimeRef.current) / 1000;
                onGameOver({
                    score: scoreRef.current,
                    obstaclesHit: obstaclesHitRef.current,
                    durationSeconds: duration
                });
            };

            const draw = (ctx, canvas) => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw Lanes
                const laneWidth = canvas.width / LANES;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 2;
                for (let i = 1; i < LANES; i++) {
                    ctx.beginPath();
                    ctx.moveTo(i * laneWidth, 0);
                    ctx.lineTo(i * laneWidth, canvas.height);
                    ctx.stroke();
                }

                // Draw Entities
                ctx.font = '32px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                entitiesRef.current.forEach(e => {
                    const x = getLaneX(e.x, canvas.width);
                    const y = (e.y / 100) * canvas.height;
                    const config = ENTITY_CONFIG[e.type];
                    
                    if (config.color) {
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = config.color;
                    }
                    ctx.fillText(config.emoji, x, y);
                    ctx.shadowBlur = 0;
                });

                // Draw Player
                const pX = getLaneX(playerRef.current.lane, canvas.width);
                const pY = (PLAYER_Y_POS / 100) * canvas.height;
                const hasDiaper = playerRef.current.effects.some(e => e.type === 'DIAPER');
                
                ctx.font = '40px Arial';
                ctx.fillText(hasDiaper ? 'ğŸ‘¶' : 'ğŸƒ', pX, pY);

                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.font = '12px Arial';
                ctx.fillText('You', pX, pY + 30);
            };

            // Loop with FPS limit
            const loop = () => {
                requestRef.current = requestAnimationFrame(loop);

                const now = Date.now();
                const elapsed = now - lastTimeRef.current;

                if (elapsed > INTERVAL) {
                    lastTimeRef.current = now - (elapsed % INTERVAL);

                    const canvas = canvasRef.current;
                    if (canvas) {
                        const ctx = canvas.getContext('2d');
                        if (ctx) {
                            updateGame(canvas);
                            draw(ctx, canvas);
                        }
                    }
                }
            };

            useEffect(() => {
                if (gameState === GameState.PLAYING) {
                    scoreRef.current = 0;
                    speedRef.current = GAME_SPEED_INITIAL;
                    frameCountRef.current = 0;
                    entitiesRef.current = [];
                    obstaclesHitRef.current = [];
                    playerRef.current = { lane: 1, isJumping: false, sanity: MAX_SANITY, effects: [], score: 0 };
                    startTimeRef.current = Date.now();
                    
                    lastTimeRef.current = Date.now();
                    requestRef.current = requestAnimationFrame(loop);
                } else {
                    if (requestRef.current) cancelAnimationFrame(requestRef.current);
                }
                return () => {
                    if (requestRef.current) cancelAnimationFrame(requestRef.current);
                };
            }, [gameState]);

            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (gameState !== GameState.PLAYING) return;
                    if (e.key === 'ArrowLeft' || e.key === 'a') {
                        playerRef.current.lane = Math.max(0, playerRef.current.lane - 1);
                    } else if (e.key === 'ArrowRight' || e.key === 'd') {
                        playerRef.current.lane = Math.min(LANES - 1, playerRef.current.lane + 1);
                    }
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [gameState]);

            return (
                <canvas 
                    ref={canvasRef} 
                    width={window.innerWidth > 480 ? 480 : window.innerWidth} 
                    height={window.innerHeight}
                    className="block mx-auto h-full"
                />
            );
        };

        // --- App Component ---

        const App = () => {
            const [gameState, setGameState] = useState(GameState.START);
            const [score, setScore] = useState(0);
            const [sanity, setSanity] = useState(MAX_SANITY);
            const [summary, setSummary] = useState(null);
            const [masterAdvice, setMasterAdvice] = useState('');
            const [visualEffects, setVisualEffects] = useState('');

            const handleGameOver = (runSummary) => {
                setSummary(runSummary);
                setGameState(GameState.GAME_OVER);
                const randomQuote = MASTER_QUOTES[Math.floor(Math.random() * MASTER_QUOTES.length)];
                setMasterAdvice(randomQuote);
            };

            const handleSanityUpdate = (val) => {
                setSanity(val);
                if (val < 30) {
                    setVisualEffects('animate-pulse text-red-500');
                } else {
                    setVisualEffects('');
                }
            };

            // è™•ç†ç§»å‹•æ§åˆ¶ (çµ±ä¸€è™•ç†è§¸æ§èˆ‡æ»‘é¼ é»æ“Š)
            const handleInput = (e, key) => {
                // é˜»æ­¢ç€è¦½å™¨é è¨­è¡Œç‚º (é¿å… ghost clicks æˆ–æ²å‹•)
                if (e.cancelable) e.preventDefault();
                e.stopPropagation();
                
                window.dispatchEvent(new KeyboardEvent('keydown', { key: key }));
            };

            return (
                <div className={`relative w-full h-screen bg-slate-900 overflow-hidden ${visualEffects}`}>
                    {/* Background */}
                    <div className="absolute inset-0 opacity-10 pointer-events-none">
                        <div className="absolute top-0 left-0 w-full h-full bg-[radial-gradient(circle_at_center,_var(--tw-gradient-stops))] from-slate-800 via-slate-900 to-black"></div>
                    </div>

                    {/* Game Canvas */}
                    <div className="absolute inset-0 z-0">
                        <GameCanvas 
                            gameState={gameState} 
                            setGameState={setGameState} 
                            onGameOver={handleGameOver}
                            onScoreUpdate={setScore}
                            onSanityUpdate={handleSanityUpdate}
                        />
                    </div>

                    {/* UI Overlay */}
                    <div className="absolute inset-0 z-10 pointer-events-none flex flex-col justify-between p-4">
                        
                        {/* HUD */}
                        {gameState === GameState.PLAYING && (
                            <div className="flex justify-between items-start">
                                <div className="bg-black/50 p-2 rounded-lg backdrop-blur-sm border border-slate-700">
                                    <p className="text-xs text-slate-400 uppercase tracking-wider">Score</p>
                                    <p className="text-2xl font-bold font-mono text-white">{score.toLocaleString()}</p>
                                </div>
                                
                                <div className="w-1/2 max-w-xs">
                                    <div className="flex justify-between text-xs mb-1">
                                        <span className="text-white font-bold">Mental Clarity (è¦ºçŸ¥)</span>
                                        <span className={`${sanity < 30 ? 'text-red-500 animate-bounce' : 'text-cyan-400'}`}>{Math.floor(sanity)}%</span>
                                    </div>
                                    <div className="w-full bg-slate-800 h-4 rounded-full overflow-hidden border border-slate-600">
                                        <div 
                                            className={`h-full transition-all duration-300 ${sanity > 60 ? 'bg-cyan-500' : sanity > 30 ? 'bg-yellow-500' : 'bg-red-600'}`}
                                            style={{ width: `${sanity}%` }}
                                        ></div>
                                    </div>
                                    {sanity < 30 && <p className="text-red-400 text-xs mt-1 text-center font-bold">Warning: Hallucinations Imminent</p>}
                                </div>
                            </div>
                        )}

                        {/* Start Screen */}
                        {gameState === GameState.START && (
                            <div className="absolute inset-0 bg-black/80 backdrop-blur-md flex flex-col items-center justify-center text-center p-6 pointer-events-auto z-50">
                                <h1 className="text-5xl font-bold mb-2 bg-clip-text text-transparent bg-gradient-to-r from-cyan-400 to-purple-500 drop-shadow-lg">
                                    è¦ºçŸ¥ä¹‹è·¯
                                </h1>
                                <h2 className="text-xl text-slate-300 mb-8 tracking-widest">Mindful Runner</h2>
                                
                                <div className="bg-slate-800/80 p-6 rounded-xl border border-slate-600 max-w-md w-full mb-8 shadow-2xl">
                                    <p className="text-slate-300 mb-4 leading-relaxed">
                                        é€ƒé›¢æ¯’å“çš„è¿·éœ§ã€‚åœ¨é€™å€‹ç„¡ç›¡çš„è·‘é…·ä¸­ï¼Œä½ éœ€è¦èº²é¿èª˜æƒ‘ï¼Œä¿æŒæ¸…é†’ã€‚
                                    </p>
                                    <div className="grid grid-cols-2 gap-4 text-left text-sm mb-4">
                                        <div className="flex items-center gap-2"><span className="text-2xl">ğŸ¼</span> <span>Kä»–å‘½</span></div>
                                        <div className="flex items-center gap-2"><span className="text-2xl">ğŸŒ¿</span> <span>å¤§éº»</span></div>
                                        <div className="flex items-center gap-2"><span className="text-2xl">ğŸ’Š</span> <span>å®‰éä»–å‘½</span></div>
                                        <div className="flex items-center gap-2"><span className="text-2xl">ğŸ§˜</span> <span>ç¦ªä¿®</span></div>
                                    </div>
                                    <button 
                                        onClick={() => setGameState(GameState.PLAYING)}
                                        className="w-full mt-4 px-8 py-4 bg-gradient-to-r from-cyan-600 to-blue-600 hover:from-cyan-500 hover:to-blue-500 text-white font-bold rounded-full text-xl shadow-lg transform hover:scale-105 transition-all"
                                    >
                                        é–‹å§‹æ—…ç¨‹
                                    </button>
                                </div>
                            </div>
                        )}

                        {/* Game Over Screen */}
                        {gameState === GameState.GAME_OVER && (
                            <div className="absolute inset-0 bg-slate-900/95 backdrop-blur-md flex flex-col items-center justify-center text-center p-6 pointer-events-auto z-50 overflow-y-auto">
                                <h2 className="text-4xl font-bold text-red-500 mb-2">è¿·å¤±è‡ªæˆ‘</h2>
                                <p className="text-slate-400 mb-6">Game Over</p>
                                
                                <div className="text-6xl font-mono font-bold text-white mb-6">
                                    {score.toLocaleString()}
                                </div>

                                <div className="bg-slate-800 p-6 rounded-xl border border-slate-700 max-w-md w-full mb-6">
                                    <h3 className="text-cyan-400 font-bold mb-2 border-b border-slate-700 pb-2">å¸«çˆ¶çš„é–‹ç¤º (Master's Guidance)</h3>
                                    <p className="text-slate-200 leading-relaxed text-sm mb-4 text-left">
                                        {masterAdvice}
                                    </p>
                                    {summary && summary.obstaclesHit.length > 0 && (
                                        <div className="flex gap-2 flex-wrap mt-2">
                                            <span className="text-xs text-slate-500">æ­»å› /é­é‡:</span>
                                            {Array.from(new Set(summary.obstaclesHit)).map(hit => (
                                                <span key={hit} className="px-2 py-1 bg-red-900/50 text-red-200 text-xs rounded border border-red-800">
                                                    {hit}
                                                </span>
                                            ))}
                                        </div>
                                    )}
                                </div>

                                <div className="flex gap-4">
                                    <button 
                                        onClick={() => setGameState(GameState.START)}
                                        className="px-6 py-3 bg-slate-700 hover:bg-slate-600 text-white font-bold rounded-lg transition-colors"
                                    >
                                        å›åˆ°é¦–é 
                                    </button>
                                    <button 
                                        onClick={() => setGameState(GameState.PLAYING)}
                                        className="px-6 py-3 bg-cyan-600 hover:bg-cyan-500 text-white font-bold rounded-lg shadow-lg shadow-cyan-500/30 transition-colors"
                                    >
                                        å†è©¦ä¸€æ¬¡
                                    </button>
                                </div>
                            </div>
                        )}
                    </div>

                    {/* Touch / Mouse Controls (ä¿®æ­£ç‰ˆ) */}
                    {gameState === GameState.PLAYING && (
                        <div className="absolute inset-0 z-20 flex">
                            <div 
                                className="w-1/2 h-full active:bg-white/5 transition-colors cursor-pointer"
                                onPointerDown={(e) => handleInput(e, 'ArrowLeft')}
                            ></div>
                            <div 
                                className="w-1/2 h-full active:bg-white/5 transition-colors cursor-pointer"
                                onPointerDown={(e) => handleInput(e, 'ArrowRight')}
                            ></div>
                        </div>
                    )}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>